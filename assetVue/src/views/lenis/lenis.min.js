!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Lenis = t(e) }(this, (function (e) { "use strict"; var t = function () { return t = Object.assign || function (e) { for (var t, o = 1, i = arguments.length; o < i; o++)for (var n in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, t.apply(this, arguments) }; function o(e, t, o, i) { return new (o || (o = Promise))((function (n, s) { function r(e) { try { a(i.next(e)) } catch (e) { s(e) } } function l(e) { try { a(i.throw(e)) } catch (e) { s(e) } } function a(e) { var t; e.done ? n(e.value) : (t = e.value, t instanceof o ? t : new o((function (e) { e(t) }))).then(r, l) } a((i = i.apply(e, t || [])).next()) })) } function i(e, t) { var o, i, n, s, r = { label: 0, sent: function () { if (1 & n[0]) throw n[1]; return n[1] }, trys: [], ops: [] }; return s = { next: l(0), throw: l(1), return: l(2) }, "function" == typeof Symbol && (s[Symbol.iterator] = function () { return this }), s; function l(s) { return function (l) { return function (s) { if (o) throw new TypeError("Generator is already executing."); for (; r;)try { if (o = 1, i && (n = 2 & s[0] ? i.return : s[0] ? i.throw || ((n = i.return) && n.call(i), 0) : i.next) && !(n = n.call(i, s[1])).done) return n; switch (i = 0, n && (s = [2 & s[0], n.value]), s[0]) { case 0: case 1: n = s; break; case 4: return r.label++, { value: s[1], done: !1 }; case 5: r.label++, i = s[1], s = [0]; continue; case 7: s = r.ops.pop(), r.trys.pop(); continue; default: if (!(n = (n = r.trys).length > 0 && n[n.length - 1]) && (6 === s[0] || 2 === s[0])) { r = 0; continue } if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) { r.label = s[1]; break } if (6 === s[0] && r.label < n[1]) { r.label = n[1], n = s; break } if (n && r.label < n[2]) { r.label = n[2], r.ops.push(s); break } n[2] && r.ops.pop(), r.trys.pop(); continue }s = t.call(e, r) } catch (e) { s = [6, e], i = 0 } finally { o = n = 0 } if (5 & s[0]) throw s[1]; return { value: s[0] ? s[1] : void 0, done: !0 } }([s, l]) } } } var n = function () { function e(e) { void 0 === e && (e = {}), this.duration = e.duration || 1.2, this.easing = e.easing || function (e) { return Math.min(1, 1.001 - Math.pow(2, -10 * e)) }, this.smoothWheel = e.smoothWheel || this.smoothWheel, this.smoothTouch = e.smoothTouch || !1, this.normalizeWheel = e.normalizeWheel || !1, this.wheelMultiplier = e.wheelMultiplier || 1, this.touchMultiplier = e.touchMultiplier || 2, this.autoRaf = !0, this.raf = this.raf.bind(this), this.options = e, this.animate = new class { constructor() { this.time = 0, this.start = 0, this.now = performance.now(), this.fps = 0, this.frames = 0, this.maxFps = 60, this.delta = 0, this.isRaf = !1, this.isTicking = !1, this.tick = this.tick.bind(this) } tick(e) { this.isRaf || (this.now = e, this.time = this.now - this.start, this.delta = this.time / 1e3, this.frames++, this.frames >= this.maxFps && (this.fps = Math.round(1e3 / this.delta), this.frames = 0, this.start = this.now), this.isTicking = !0) } start() { this.isRaf = !1, this.isTicking || (this.isTicking = !0, this.start = performance.now() - this.time, requestAnimationFrame(this.tick)) } stop() { this.isRaf = !1, this.isTicking = !1 } raf() { this.isRaf = !0 } }, this.scroll = 0, this.velocity = 0, this.target = 0, this.last = 0, this.direction = 0, this.isScrolling = !1, this.isStopped = !1, this.isLocked = !1, this.isSmooth = this.smoothWheel || this.smoothTouch, this.wheel = new class { constructor(e) { this.lenis = e, this.start = 0, this.velocity = 0, this.wheel = new class { constructor() { this.x = 0, this.y = 0 } reset() { this.x = this.y = 0 } }reset(), this.touch = new class { constructor() { this.x = 0, this.y = 0, this.start = 0, this.velocity = 0 } reset() { this.x = this.y = this.start = this.velocity = 0 } } }({ lenis: this }), this.resize(), this.autoRaf && this.animate.start() }get limit(){ return this.isHorizontal ? Math.max(0, this.contentWidth - this.wrapperWidth) : Math.max(0, this.contentHeight - this.wrapperHeight) }get isHorizontal(){ return this.options.orientation === "horizontal" }get wrapper(){ return this.options.wrapper || window }get content(){ return this.options.content || this.wrapper === window ? document.documentElement : this.options.content }get wrapperWidth(){ return this.wrapper === window ? window.innerWidth : this.wrapper.clientWidth }get wrapperHeight(){ return this.wrapper === window ? window.innerHeight : this.wrapper.clientHeight }get contentWidth(){ return this.content.scrollWidth }get contentHeight(){ return this.content.scrollHeight } resize(){ this.wrapperWidth = this.wrapperWidth(), this.wrapperHeight = this.wrapperHeight(), this.contentWidth = this.contentWidth(), this.contentHeight = this.contentHeight(), this.limit = this.limit } emit(){ this.emitter && this.emitter.emit("scroll", this) } on(e, t){ return this.emitter || (this.emitter = new class { constructor() { this.events = {} } on(e, t) { this.events[e] || (this.events[e] = []), this.events[e].push(t) } off(e, t) { this.events[e] && this.events[e].splice(this.events[e].indexOf(t), 1) } emit(e, ...t) { this.events[e] && this.events[e].forEach((e => e(...t))) } }), this.emitter.on(e, t), this } off(e, t){ this.emitter && this.emitter.off(e, t) } destroy(){ this.emitter = null, this.stop(), this.animate.stop(), this.wheel = null, this.touch = null, this.options = null } scrollTo(e, t){ void 0 === t && (t = {}), t.offset && (e = this.isHorizontal ? e + this.options.offset : e + t.offset), t.immediate ? (this.isHorizontal ? this.content.scrollLeft = e : this.content.scrollTop = e, this.target = this.scroll = e, this.velocity = 0, this.isScrolling = !1, this.emit()) : t.lerp ? this.target = e : this.target = this.scroll = e, this.animate.start(), this.isScrolling = !0, this.isStopped = !1, this.raf() } raf(e){ this.animate.raf(e), this.delta = this.animate.delta, this.scroll = this.isHorizontal ? this.content.scrollLeft : this.content.scrollTop, this.direction = Math.sign(this.scroll - this.last), this.velocity = (this.scroll - this.last) / this.delta, this.last = this.scroll, this.isScrolling && (this.target = this.scroll, this.isScrolling = !1), this.autoRaf && requestAnimationFrame(this.raf) } start(){ this.isStopped = !1, this.animate.start() } stop(){ this.isStopped = !0, this.animate.stop() } lock(){ this.isLocked = !0 } unlock(){ this.isLocked = !1 } normalize(e){ return e / (e < 1 ? 1 : 2) } lerp(e, t, o){ return e + (t - e) * o } clamp(e, t, o){ return Math.max(t, Math.min(o, e)) } smoothStep(e){ return e * e * (3 - 2 * e) } return e }return e })); var s = function () { function e(e) { this.lenis = e, this.now = 0, this.last = 0, this.velocity = 0, this.start = 0, this.isScrolling = !1, this.isTouching = !1, this.client = new class { constructor() { this.x = 0, this.y = 0 } reset() { this.x = this.y = 0 } }reset(), this.touch = new class { constructor() { this.x = 0, this.y = 0, this.start = 0, this.velocity = 0 } reset() { this.x = this.y = this.start = this.velocity = 0 } }reset() } onPointerDown(e){ this.isTouching = !0, this.client.x = e.clientX, this.client.y = e.clientY, this.touch.x = e.clientX, this.touch.y = e.clientY, this.touch.start = this.touch.y, this.isScrolling = !1 } onPointerMove(e){ this.now = performance.now(), this.touch.x = e.clientX, this.touch.y = e.clientY, this.velocity = (this.touch.y - this.touch.start) / (this.now - this.last), this.last = this.now, this.touch.start = this.touch.y } onPointerUp(){ this.isTouching = !1, this.velocity = 0 } return e }return e}(); e.Lenis = n, e.default = n, Object.defineProperty(e, "__esModule", { value: !0 })}));